import os

import iob_colors
import if_gen
from iob_verilog_instance import iob_verilog_instance

# Generic class to describe a base iob-module
class iob_module:
    # Standard attributes common to all iob-modules
    name="iob_module" # Verilog module name (not instance name)
    version="1.0" # Module version
    flows="" # Flows supported by this module
    setup_dir="" # Setup directory for this module
    build_dir="" # Build directory for this module
    confs=[] # List of configuration macros/parameters for this module
    regs=[] # List of registers for this module
    ios=[] # List of I/O for this module
    block_groups=[] # List of block groups for this module. Used for documentation.

    _setup_purpose=[] # List of setup purposes for this module. Also used to check if module has already been setup.

    is_top_module=False # Select if this module is the top module

    __generated_headers = {} # Dictionary of headers generated by the `generate` method, and their purpose.


    # Public setup method for this module.
    @classmethod
    def setup(cls, purpose="hardware", is_top_module=False):
        # Don't setup if module has already been setup for this purpose or for the "hardware" purpose.
        if purpose in cls._setup_purpose or "hardware" in cls._setup_purpose:
            return

        # Only set dynamic attributes if this is the first time we run setup
        if not cls._setup_purpose:
            cls.is_top_module=is_top_module
            cls.set_dynamic_attributes()

        cls._setup_purpose.append(purpose)

        cls._run_setup()


    # Public method to create a Verilog instance of this module
    @classmethod
    def instance(cls, name="", description=""):
        assert _setup_purpose, f"{iob_colors.ERROR}Module {cls.name} has not been setup yet!{iob_colors.ENDC}"

        if not name:
            name=f"{cls.name}_0"

        # Return a new iob_verilog_instance object with these attributes that describe the Verilog instance and module.
        return iob_verilog_instance(name, description, cls)


    # Public method to set dynamic attributes
    # This method is automatically called by setup()
    @classmethod
    def set_dynamic_attributes(cls):
        # Set the build directory in the `iob_module` superclass, so everyone has access to it
        if cls.is_top_module:
            # Auto-fill build directory if its not set
            if not cls.build_dir:
                iob_module.build_dir=f"../{cls.name}_{cls.version}"
            else:
                iob_module.build_dir=cls.build_dir

        # Copy build directory from the `iob_module` superclass
        cls.build_dir=iob_module.build_dir

        # TODO: It would be nice if we could auto-fill the setup directory with the location of the file, but I'm not sure how.
        # cls.setup_dir=os.path.dirname(__file__) # This would not work, because `__file__` points to the iob_module.py file and not the ones from subclasses.

    # Default setup function just parses the latest purpose and returns the destination directory
    @classmethod
    def _run_setup(cls):
        # Get output directory for the `purpose` of this setup
        return cls.get_purpose_dir(cls._setup_purpose[-1])


    # Append confs to the current list, overriding existing ones
    @classmethod
    def _setup_confs(cls, confs):
        for conf in confs:
            for _conf in cls.confs:
                if _conf['name'] == conf['name']:
                    _conf.update(conf)
                    break
            else:
                cls.confs.append(conf)

    @classmethod
    def generate(cls, vh_name, purpose="hardware"):
        dest_dir=os.path.join(cls.build_dir, cls.get_purpose_dir(purpose))

        if (type(vh_name) is str) and (vh_name in if_gen.interfaces):
            if "iob_" in vh_name:
                file_prefix = ""
            else:
                file_prefix = "iob_"
            f_out = open(f"{dest_dir}/{file_prefix}{vh_name}.vh", "w")
            if_gen.create_signal_table(vh_name)
            if_gen.write_vh_contents(vh_name, "", "", f_out)
        elif (type(vh_name) is dict) and (vh_name["interface"] in if_gen.interfaces):
            f_out = open(
                f"{dest_dir}/{vh_name['file_prefix']}{vh_name['interface']}.vh", "w"
            )
            if_gen.create_signal_table(vh_name["interface"])
            if_gen.write_vh_contents(
                vh_name["interface"],
                vh_name["port_prefix"],
                vh_name["wire_prefix"],
                f_out,
                bus_size=vh_name["bus_size"] if "bus_size" in vh_name.keys() else 1,
                bus_start=vh_name["bus_start"] if "bus_start" in vh_name.keys() else 0,
            )
        else:
            raise Exception(
                    f"{iob_colors.FAIL} Can't generate '{vh_name}'. Type not recognized.{iob_colors.ENDC}"
                    )


    @staticmethod
    def get_purpose_dir(purpose):
        if purpose == 'hardware':
            out_dir = 'hardware/src/'
        elif purpose == 'simulation':
            out_dir = 'hardware/simulation/src/'
        elif purpose == 'fpga':
            out_dir = 'hardware/fpga/src/'
        elif purpose == 'software':
            out_dir = 'software/src/'
        else:
            raise Exception(f'{iob_colors.ERROR}Unknown purpose: {purpose}{iob_colors.ENDC}')

        return out_dir
