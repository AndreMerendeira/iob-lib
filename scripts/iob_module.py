import os
import shutil

import iob_colors
import if_gen
from mk_configuration import config_build_mk
from build_srcs import LIB_DIR
from iob_verilog_instance import iob_verilog_instance

# Generic class to describe a base iob-module
class iob_module:
    # Standard attributes common to all iob-modules
    name = "iob_module"  # Verilog module name (not instance name)
    version = "1.0"  # Module version
    flows = ""  # Flows supported by this module
    setup_dir = ""  # Setup directory for this module
    build_dir = ""  # Build directory for this module
    confs = None  # List of configuration macros/parameters for this module
    regs = None  # List of registers for this module
    ios = None  # List of I/O for this module
    block_groups = None  # List of block groups for this module. Used for documentation.

    # List of setup purposes for this module. Also used to check if module has already been setup.
    _setup_purpose = (
        None
    )

    is_top_module = False  # Select if this module is the top module

    __generated_headers = (
        {}
    )  # Dictionary of headers generated by the `generate` method, and their purpose.

    PURPOSE_DIRS = {
            'hardware': 'hardware/src',
            'simulation': 'hardware/simulation/src',
            'fpga': 'hardware/fpga/src',
            'software': 'software/src',
            }

    # Public setup method for this module.
    # purpose: Reason for setting up the module. Used to select between the standard destination locations.
    # is_top_module: Select if this is the top module. This should only be enabled on the top module class.
    @classmethod
    def setup(cls, purpose="hardware", is_top_module=False):
        #print(f'DEBUG: Setup: {cls.name}, purpose: {purpose}') # DEBUG

        # Initialize empty list for purpose
        if cls._setup_purpose == None:
            cls._setup_purpose=[]

        # Don't setup if module has already been setup for this purpose or for the "hardware" purpose.
        if purpose in cls._setup_purpose or "hardware" in cls._setup_purpose:
            return

        # Only set dynamic attributes if this is the first time we run setup
        if not cls._setup_purpose:
            cls.is_top_module = is_top_module
            cls.set_dynamic_attributes()

        # Create build directory this is the top module class, and is the first time setup
        if is_top_module and not cls._setup_purpose:
            cls.__create_build_dir()

        # Add current setup purpose to list
        cls._setup_purpose.append(purpose)

        cls._run_setup()

    # Public method to create a Verilog instance of this module
    # name: Name of the Verilog instance.
    # description: Description of the Verilog instance.
    # Returns an `iob_verilog_instance` object representing a new Verilog instance of the module calling this method.
    @classmethod
    def instance(cls, name="", description=""):
        assert (
            cls._setup_purpose
        ), f"{iob_colors.FAIL}Module {cls.name} has not been setup yet!{iob_colors.ENDC}"

        if not name:
            name = f"{cls.name}_0"

        # Return a new iob_verilog_instance object with these attributes that describe the Verilog instance and module.
        return iob_verilog_instance(name, description, cls)

    # Public method to set dynamic attributes
    # This method is automatically called by the `setup` method
    @classmethod
    def set_dynamic_attributes(cls):
        # Set the build directory in the `iob_module` superclass, so everyone has access to it
        if cls.is_top_module:
            # Auto-fill build directory if its not set
            if not cls.build_dir:
                iob_module.build_dir = f"../{cls.name}_{cls.version}"
            else:
                iob_module.build_dir = cls.build_dir

        # Copy build directory from the `iob_module` superclass
        cls.build_dir = iob_module.build_dir

        # TODO: It would be nice if we could auto-fill the setup directory with the location of the file, but I'm not sure how.
        # cls.setup_dir=os.path.dirname(__file__) # This would not work, because `__file__` points to the iob_module.py file and not the ones from subclasses.

        # Initialize empty lists for attributes (We can't initialize in the attribute declaration because it would cause every subclass to reference the same list)
        cls.confs = []
        cls.regs = []
        cls.ios = []
        cls.block_groups = []

    # Default _run_setup function just parses the latest purpose and returns the destination directory
    @classmethod
    def _run_setup(cls):
        # Get output directory for the `purpose` of this setup
        return cls.get_purpose_dir(cls._setup_purpose[-1])

    # Append confs to the current confs class list, overriding existing ones
    @classmethod
    def _setup_confs(cls, confs):
        for conf in confs:
            for _conf in cls.confs:
                if _conf["name"] == conf["name"]:
                    _conf.update(conf)
                    break
            else:
                cls.confs.append(conf)

    # Generate a Verilog header with `if_gen.py`.
    # vs_name: Either a string or a dictionary describing the interface to generate.
    #          Example string: "iob_wire"
    #          Example dictionary:
    #                {
    #                    "file_prefix": "iob_bus_0_2_",
    #                    "interface": "axi_m_portmap",
    #                    "wire_prefix": "",
    #                    "port_prefix": "",
    #                    "bus_start": 0,
    #                    "bus_size": 2,
    #                }
    # purpose: Reason for generating the header. Used to select between the standard destination locations.
    @classmethod
    def generate(cls, vs_name, purpose="hardware"):
        dest_dir = os.path.join(cls.build_dir, cls.get_purpose_dir(purpose))

        if (type(vs_name) is str) and (vs_name in if_gen.interfaces):
            if "iob_" in vs_name:
                file_prefix = ""
            else:
                file_prefix = "iob_"
            f_out = open(os.path.join(dest_dir, file_prefix+vs_name+".vs"), "w")
            if_gen.create_signal_table(vs_name)
            if_gen.write_vs_contents(vs_name, "", "", f_out)
        elif (type(vs_name) is dict) and (vs_name["interface"] in if_gen.interfaces):
            f_out = open(
                os.path.join(dest_dir, vs_name['file_prefix']+vs_name['interface']+".vs"), "w"
            )
            if_gen.create_signal_table(vs_name["interface"])
            if_gen.write_vs_contents(
                vs_name["interface"],
                vs_name["port_prefix"],
                vs_name["wire_prefix"],
                f_out,
                bus_size=vs_name["bus_size"] if "bus_size" in vs_name.keys() else 1,
                bus_start=vs_name["bus_start"] if "bus_start" in vs_name.keys() else 0,
            )
        else:
            raise Exception(
                f"{iob_colors.FAIL} Can't generate '{vs_name}'. Type not recognized.{iob_colors.ENDC}"
            )

    # Get output directory based on the purpose given.
    @classmethod
    def get_purpose_dir(cls, purpose):
        assert purpose in cls.PURPOSE_DIRS, f"{iob_colors.FAIL}Unknown purpose {purpose}{iob_colors.ENDC}"
        return cls.PURPOSE_DIRS[purpose]

    # Create build directory. Must be called from the top module.
    @classmethod
    def __create_build_dir(cls):
        assert cls.is_top_module, f"{iob_colors.FAIL}Module {cls.name} is not a top module!{iob_colors.ENDC}"
        os.makedirs(cls.build_dir, exist_ok=True)
        config_build_mk(cls)
        # Create hardware directories
        os.makedirs(
            f"{cls.build_dir}/hardware/src", exist_ok=True
        )
        if 'sim' in cls.flows:
            os.makedirs(
                f"{cls.build_dir}/hardware/simulation/src", exist_ok=True
            )
        if 'fpga' in cls.flows:
            os.makedirs(
                f"{cls.build_dir}/hardware/fpga/src", exist_ok=True
            )

        shutil.copyfile(
            f"{LIB_DIR}/build.mk", f"{cls.build_dir}/Makefile"
        )  # Copy generic MAKEFILE
