#!/usr/bin/env python3
#
#    Build Latex tables of verilog module interface signals and registers
#

import sys
from parse import parse
import math

regvfile_name = ''

#name, type, address, width, default value, description

def write_hw(table):

    global regvfile_name
    fout = open (regvfile_name+'_gen.vh', 'w')

    fout.write("//This file was generated by script mkregs.py\n\n")

    fout.write("\n\n//write registers\n")
    for row in table:
        name = row[0]
        typ = row[1]
        address = row[2]
        width = row[3]
        default_val = row[4]

        if (typ == 'W'):
            fout.write("`IOB_REG_ARE(clk, rst, " + default_val + ", valid & wstrb & (address == " + str(int(address)>>2) + "), "
                       + name + ", wdata["+width+"-1:0])\n")
        else:
            continue

    fout.write("\n\n//read registers\n")
    fout.write("`IOB_VAR(rdata_int, DATA_W)\n")
    fout.write("`IOB_VAR(rdata_int2, DATA_W)\n")
    fout.write("`IOB_REG_ARE(clk, rst, 0, valid, rdata_int2, rdata_int)\n")
    fout.write("`IOB_VAR2WIRE(rdata_int2, rdata)\n\n")

    fout.write("always @* begin\n")
    fout.write("   case(address)\n")

    for row in table:
        name = row[0]
        typ = row[1]
        address = row[2]
        width = row[3]
        default_val = row[4]

        if (typ == 'R'):
            fout.write("     " + str(int(address)>>2) + ": rdata_int = " + name + ";\n")
        else:
            continue

    fout.write("     default: rdata_int = 1'b0;\n")
    fout.write("   endcase\n")
    fout.write("end\n")

    #ready signal
    fout.write("`IOB_VAR(ready_int, 1)\n")
    fout.write("`IOB_REG_AR(clk, rst, 0, ready_int, valid)\n")
    fout.write("`IOB_VAR2WIRE(ready_int, ready)\n")

    fout.close()


def write_hwheader(table):

    global regvfile_name
    fout = open(regvfile_name+'_def.vh', 'w')

    fout.write("//This file was generated by script mkregs.py\n\n")

    fout.write("//address width\n")
    fout.write("`define " + regvfile_name + "_ADDR_W " + str(int(math.ceil(math.log(len(table), 2)))) + "\n\n")

    fout.write("//address macros\n")
    for row in table:
        name = row[0]
        address = row[2]
        fout.write("`define " + name + "_ADDR " + str(int(address)>>2) + "\n")

    fout.write("\n//registers width\n")
    for row in table:
        name = row[0]
        width = row[3]
        fout.write("`define " + name + "_W " + width + "\n")

    fout.close()

# Get C type from swreg width
# use IOB_TYPES defined in LIB/software/include/iob-lib.h
# width: SWREG width
# sign: 0 unsigned type, 1 signed type
def swreg_type(width, sign=0):
    width_int = int(width)
    if width_int < 1:
        print(f'MKREGS: invalid SWREG width value {width}.')
        width_int = 64
    
    if sign:
        type_dict = dict([(8, 'IOB_INT8_T'), (16, 'IOB_INT16_T'), 
            (32, 'IOB_INT32_T')])
        default_width = 'IOB_INT64_T'
    else:
        type_dict = dict([(8, 'IOB_UINT8_T'), (16, 'IOB_UINT16_T'), 
            (32, 'IOB_UINT32_T')])
        default_width = 'IOB_UINT64_T'
    
    # next 8*2^k last enough to store width
    next_pow2 = 2**(math.ceil(math.log2(math.ceil(width_int/8))))
    sw_width = 8*next_pow2

    return type_dict.get(sw_width, default_width)

def write_swheader(table):

    global regvfile_name
    fout = open(regvfile_name+'.h', 'w')

    fout.write("//This file was generated by script mkregs.py\n\n")

    fout.write("//register address mapping\n")
    for row in table:
        name = row[0]
        address = row[2]
        width = row[3]
        fout.write("#define " + name + " " + address + "\n")
        # define SWREG software type
        reg_type = swreg_type(width)
        if reg_type:
            fout.write("#define " + name + "_TYPE " + reg_type + "\n")

    fout.close()


swreg_addr = 0
def swreg_parse (code, hwsw):
    global swreg_addr
    table = [] #name, type, address, width, default value, description

    for line in code:

        swreg_flds = []
        swreg_flds_tmp = parse('{}`IOB_SWREG_{}({},{},{}){}//{}', line)

        if swreg_flds_tmp is None:
            swreg_flds_tmp = parse('`IOB_SWREG_{}({},{},{}){}//{}', line)
            if swreg_flds_tmp is None: continue #not a sw reg
        else:
            swreg_flds_tmp = swreg_flds_tmp[1:]

        #NAME
        swreg_flds.append(swreg_flds_tmp[1].strip(' '))

        #TYPE
        swreg_flds.append(swreg_flds_tmp[0])

        #ADDRESS
        swreg_width = swreg_flds_tmp[2]
        swreg_flds.append(str(swreg_addr))
        swreg_addr = swreg_addr + 4

        #WIDTH
        swreg_flds.append(swreg_width)

        #DEFAULT VALUE
        swreg_flds.append(swreg_flds_tmp[3])

        #DESCRIPTION
        swreg_flds.append(swreg_flds_tmp[5])

        table.append(swreg_flds)


    if(hwsw == "HW"):
        write_hwheader(table)
        write_hw(table)

    elif(hwsw == "SW"):
        write_swheader(table)

def main () :

    global regvfile_name

    #parse command line
    if len(sys.argv) != 3:
        print("Usage: ./mkregs.py TOP_swreg.vh [HW|SW]")
        print(" TOP_swreg.vh:the software accessible registers definitions file")
        print(" [HW|SW]: use HW to generate the hardware files or SW to generate the software files")
        quit()
    else:
        regvfile_name = sys.argv[1]
        hwsw = sys.argv[2]

    #parse input file
    fin = open (regvfile_name, 'r')
    defsfile = fin.readlines()
    fin.close()

    regvfile_name = regvfile_name.split('/')[-1].split('.')[0]

    swreg_parse (defsfile, hwsw)

if __name__ == "__main__" : main ()
