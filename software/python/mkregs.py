#!/usr/bin/env python3
#
#    Build Latex tables of verilog module interface signals and registers
#

import sys
from parse import parse
import math

#name, type, address, width, default value, description

def write_hw(table, regvfile_name):

    fout = open (regvfile_name+'_gen.vh', 'w')

    fout.write("//This file was generated by script mkregs.py\n\n")

    fout.write("\n\n//write registers\n")
    for row in table:
        name = row[0]
        typ = row[1]
        address = row[2]
        width = row[3]
        default_val = row[4]

        if (typ == 'W'):
            fout.write("`IOB_REG_ARE(clk, rst, " + default_val + ", valid & wstrb & (address == " + str(int(address)>>2) + "), "
                       + name + ", wdata["+width+"-1:0])\n")
        else:
            continue

    fout.write("\n\n//read registers\n")
    fout.write("`IOB_VAR(rdata_int, DATA_W)\n")
    fout.write("`IOB_VAR(rdata_int2, DATA_W)\n")
    fout.write("`IOB_REG_ARE(clk, rst, 0, valid, rdata_int2, rdata_int)\n")
    fout.write("`IOB_VAR2WIRE(rdata_int2, rdata)\n\n")

    fout.write("always @* begin\n")
    fout.write("   case(address)\n")

    for row in table:
        name = row[0]
        typ = row[1]
        address = row[2]
        width = row[3]
        default_val = row[4]

        if (typ == 'R'):
            fout.write("     " + str(int(address)>>2) + ": rdata_int = " + name + ";\n")
        else:
            continue

    fout.write("     default: rdata_int = 1'b0;\n")
    fout.write("   endcase\n")
    fout.write("end\n")

    #ready signal
    fout.write("`IOB_VAR(ready_int, 1)\n")
    fout.write("`IOB_REG_AR(clk, rst, 0, ready_int, valid)\n")
    fout.write("`IOB_VAR2WIRE(ready_int, ready)\n")

    fout.close()


def write_hwheader(table, regvfile_name):

    fout = open(regvfile_name+'_def.vh', 'w')

    fout.write("//This file was generated by script mkregs.py\n\n")

    fout.write("//address width\n")
    fout.write("`define " + regvfile_name + "_ADDR_W " + str(int(math.ceil(math.log(len(table), 2)))) + "\n\n")

    fout.write("//address macros\n")
    for row in table:
        name = row[0]
        address = row[2]
        fout.write("`define " + name + "_ADDR " + str(int(address)>>2) + "\n")

    fout.write("\n//registers width\n")
    for row in table:
        name = row[0]
        width = row[3]
        fout.write("`define " + name + "_W " + width + "\n")

    fout.close()

# Get C type from swreg width
# uses unsigned int types from C stdint library
# width: SWREG width
def swreg_type(width):
    # Check if width is a number string (1, 8, 15, etc)
    try:
        width_int = int(width)
    except:
        # if width is a parameter (example: DATA_W, etc, set default width)
        width_int = 32

    if width_int < 1:
        print(f'MKREGS: invalid SWREG width value {width}.')
        width_int = 32
    
    type_dict = dict([(8, 'uint8_t'), (16, 'uint16_t'), (32, 'uint32_t')])
    default_width = 'uint64_t'
    
    # next 8*2^k last enough to store width
    next_pow2 = 2**(math.ceil(math.log2(math.ceil(width_int/8))))
    sw_width = 8*next_pow2

    return type_dict.get(sw_width, default_width)

def write_swheader(table, regvfile_name, core_prefix):

    fout = open(regvfile_name+'.h', 'w')

    fout.write("//This file was generated by script mkregs.py\n\n")
    fout.write("#ifndef H_IOB_UART_SWREG_EMBEDDED_H\n")
    fout.write("#define H_IOB_UART_SWREG_EMBEDDED_H\n\n")
    fout.write("#include <stdint.h>\n\n")

    fout.write("//register address mapping\n")
    for row in table:
        name = row[0]
        address = row[2]
        fout.write("#define " + name + " " + address + "\n")

    fout.write("\n// Base Address\n")
    fout.write("static int base;\n")
    fout.write(f"void {core_prefix}_INIT_BASEADDR(uint32_t addr);\n")

    fout.write("\n// Core Setters\n")
    for row in table:
        read_write = row[1]
        if read_write == "W":
            name = row[0]
            width = row[3]
            parsed_name = name.split("_",1)[1]
            sw_type = swreg_type(width)
            fout.write(f"void {core_prefix}_SET_{parsed_name}({sw_type} value);\n")

    fout.write("\n// Core Getters\n")
    for row in table:
        read_write = row[1]
        if read_write == "R":
            name = row[0]
            width = row[3]
            parsed_name = name.split("_",1)[1]
            sw_type = swreg_type(width)
            fout.write(f"{sw_type} {core_prefix}_GET_{parsed_name}();\n")

    fout.write("\n#endif // H_IOB_UART_SWREG_EMBEDDED_H\n")

    fout.close()

def write_sw_emb(table, regvfile_name, core_prefix):

    fout = open(regvfile_name+'_emb.c', 'w')

    fout.write("//This file was generated by script mkregs.py\n\n")

    swheader_name = regvfile_name+'.h'
    fout.write(f"#include \"{swheader_name}\"\n\n")

    fout.write("\n// Base Address\n")
    fout.write(f"void {core_prefix}_INIT_BASEADDR(uint32_t addr) {{\n")
    fout.write(f"\tbase = addr;\n")
    fout.write(f"}}\n")

    fout.write("\n// Core Setters\n")
    for row in table:
        read_write = row[1]
        if read_write == "W":
            name = row[0]
            width = row[3]
            parsed_name = name.split("_",1)[1]
            sw_type = swreg_type(width)
            fout.write(f"void {core_prefix}_SET_{parsed_name}({sw_type} value) {{\n")
            fout.write(f"\t(*( (volatile {sw_type} *) ( (base) + ({name}) ) ) = (value));\n")
            fout.write(f"}}\n\n")

    fout.write("\n// Core Getters\n")
    for row in table:
        read_write = row[1]
        if read_write == "R":
            name = row[0]
            width = row[3]
            parsed_name = name.split("_",1)[1]
            sw_type = swreg_type(width)
            fout.write(f"{sw_type} {core_prefix}_SET_{parsed_name}() {{\n")
            fout.write(f"\treturn (*( (volatile {sw_type} *) ( (base) + ({name}) ) ));\n")
            fout.write(f"}}\n\n")

    fout.close()


def swreg_parse (code, hwsw, regvfile_name, core_prefix):
    swreg_addr = 0
    table = [] #name, type, address, width, default value, description

    for line in code:

        swreg_flds = []
        swreg_flds_tmp = parse('{}`IOB_SWREG_{}({},{},{}){}//{}', line)

        if swreg_flds_tmp is None:
            swreg_flds_tmp = parse('`IOB_SWREG_{}({},{},{}){}//{}', line)
            if swreg_flds_tmp is None: continue #not a sw reg
        else:
            swreg_flds_tmp = swreg_flds_tmp[1:]

        #NAME
        swreg_flds.append(swreg_flds_tmp[1].strip(' '))

        #TYPE
        swreg_flds.append(swreg_flds_tmp[0])

        #ADDRESS
        swreg_width = swreg_flds_tmp[2]
        swreg_flds.append(str(swreg_addr))
        swreg_addr = swreg_addr + 4

        #WIDTH
        swreg_flds.append(swreg_width)

        #DEFAULT VALUE
        swreg_flds.append(swreg_flds_tmp[3])

        #DESCRIPTION
        swreg_flds.append(swreg_flds_tmp[5])

        table.append(swreg_flds)


    if(hwsw == "HW"):
        write_hwheader(table, regvfile_name)
        write_hw(table, regvfile_name)

    elif(hwsw == "SW"):
        write_swheader(table, regvfile_name, core_prefix)
        write_sw_emb(table, regvfile_name, core_prefix)

def print_usage():
    print("Usage: ./mkregs.py TOP_swreg.vh [HW|SW] [CORE_PREFIX]")
    print(" TOP_swreg.vh:the software accessible registers definitions file")
    print(" [HW|SW]: use HW to generate the hardware files or SW to generate the software files")
    print(" [CORE_PREFIX]: (SW only) core prefix name. This is added as sw function prefix")

def main () :

    #parse command line
    if len(sys.argv) < 3:
        print_usage()
        quit()
    else:
        regvfile_name = sys.argv[1]
        hwsw = sys.argv[2]

    core_prefix = ""
    if hwsw == "SW":
        try:
            core_prefix = sys.argv[3]
        except:
            print(" Expected [CORE_PREFIX] in SW mode. Check Usage.")
            print_usage()
            quit()


    #parse input file
    fin = open (regvfile_name, 'r')
    defsfile = fin.readlines()
    fin.close()

    regvfile_name = regvfile_name.split('/')[-1].split('.')[0]

    swreg_parse (defsfile, hwsw, regvfile_name, core_prefix)

if __name__ == "__main__" : main ()
